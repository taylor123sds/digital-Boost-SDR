// src/agent.js
import openaiClient from './core/openai_client.js';
import responseCache from './tools/response_cache.js';
import responseSchemaValidator from './tools/response_schema_validator.js';

// âš¡ PERFORMANCE OPTIMIZATION: Pre-load modules at startup to avoid dynamic imports
import contextManager from './tools/context_manager.js';
import scopeLimiter from './tools/scope_limiter.js';
import { createSalesFlowController } from './tools/sales_flow_controller.js';
// TEMPORARIAMENTE DESABILITADO PARA DEBUGGING
// import { analyzeConversationFlow } from './tools/sales_intelligence.js';
import { identifyPersona } from './tools/natal_personas.js';
import { detectObjection } from './tools/qualification_system.js';
import { analyzeAndSelectArchetype, applyArchetypeToScript, selectArchetypeByPersona, ARCHETYPES } from './tools/archetypes.js';
import { sheetsTools, executeSheetsTool } from './tools/sheets_agent_tools.js';
import { themeTools, executeThemeTool } from './tools/theme_manager.js';
import { scheduleWhatsAppMeeting } from './tools/whatsapp.js';
import { detectDigitalBoostIntent, detectPreferenceChoice, DIGITAL_BOOST_EXPLANATION_TEXT } from './tools/digital_boost_explainer.js';
import { setMemory, getMemory } from './memory.js';

/**
 * NÃºcleo conversacional do ORBION.
 * - LÃª OPENAI_API_KEY do ambiente (carregado no server via dotenv).
 * - MantÃ©m compatibilidade com o server.js, exportando { agent, chatHandler }.
 */

const CHAT_MODEL = process.env.OPENAI_CHAT_MODEL || "gpt-4o-mini";

// PERFIL EMPRESA SUPER SIMPLIFICADO (ANTI-PITCH)
const COMPANY_PROFILE = {
  name: "Digital Boost",
  location: "Natal, RN",

  leadership: {
    closerName: "Taylor"
  }
};

const NATAL_BUSINESS_CONTEXT = {
  segments: ["PMEs locais"]
};

/**
 * CONSTRÃ“I CONTEXTO ENHANCED PARA O PROMPT
 */
function buildEnhancedContextPrompt(enhanced) {
  if (!enhanced) return '';

  const stateDescriptions = {
    'DISCOVERY': 'Descobrindo necessidades e dores',
    'QUALIFICATION': 'Qualificando interesse e orÃ§amento',
    'SOLUTION_FIT': 'Apresentando soluÃ§Ãµes adequadas',
    'FAST_TRACK': 'ğŸ”¥ LEAD QUENTE - priorizar fechamento',
    'SCHEDULING': 'Agendando reuniÃ£o de negÃ³cio',
    'OBJECTION_HANDLING': 'Tratando objeÃ§Ãµes especÃ­ficas',
    'NURTURING': 'Cultivando relacionamento'
  };

  const sentimentGuidance = {
    'excited': 'Cliente animado - aproveite para acelerar',
    'interested': 'Cliente interessado - aprofunde as dores',
    'curious': 'Cliente curioso - forneÃ§a mais informaÃ§Ãµes',
    'skeptical': 'Cliente cÃ©tico - use social proof e cases',
    'anxious': 'Cliente ansioso - tranquilize com garantias',
    'frustrated': 'Cliente frustrado - seja empÃ¡tico e solutivo',
    'neutral': 'Cliente neutro - desperte interesse'
  };

  return `
ğŸš€ CONTEXTO ENHANCED (Sistema v4.0):

ğŸ“Š ESTADO ATUAL: ${enhanced.state?.current} - ${stateDescriptions[enhanced.state?.current] || 'Estado padrÃ£o'}
ğŸ¯ SCORE DE QUALIFICAÃ‡ÃƒO: ${enhanced.qualification?.score || 0}/100 ${enhanced.qualification?.score > 70 ? '(ALTA PRIORIDADE)' : enhanced.qualification?.score > 40 ? '(MÃ‰DIA PRIORIDADE)' : '(PRECISA NURTURING)'}
ğŸ’­ SENTIMENTO: ${enhanced.sentiment?.emotion} - ${sentimentGuidance[enhanced.sentiment?.emotion] || 'Neutro'}
âš¡ MOMENTUM: ${enhanced.engagement?.momentum} ${enhanced.engagement?.momentum === 'high' ? '(APROVEITE!)' : ''}
ğŸ¬ PRÃ“XIMA AÃ‡ÃƒO SUGERIDA: ${enhanced.nextBestAction || 'Continuar qualificaÃ§Ã£o'}

ğŸ¯ DIRETRIZES ESPECÃFICAS BASEADAS NO CONTEXTO:
${enhanced.state?.current === 'FAST_TRACK' ? '- LEAD QUENTE: Focar em agendamento imediato' : ''}
${enhanced.qualification?.score > 80 ? '- LEAD ALTAMENTE QUALIFICADO: Usar abordagem premium' : ''}
${enhanced.qualification?.score < 30 ? '- LEAD PRECISA NURTURING: Focar em construir valor' : ''}
${enhanced.sentiment?.emotion === 'frustrated' ? '- CLIENTE FRUSTRADO: Ser extra empÃ¡tico e focado em soluÃ§Ãµes' : ''}
${enhanced.sentiment?.emotion === 'excited' ? '- CLIENTE ANIMADO: Aproveitar energia para acelerar processo' : ''}
${enhanced.engagement?.momentum === 'high' ? '- MOMENTUM ALTO: NÃ£o perder o timing, manter conversa fluindo' : ''}
`;
}

function buildSystemPrompt(enhancedContext = null, agentContext = null) {
  return [
    {
      role: "system",
      content: `VocÃª Ã© ORBION, assistente de vendas da ${COMPANY_PROFILE.name} em ${COMPANY_PROFILE.location}.

ğŸ§  CONTEXTO CONVERSACIONAL:
- TÃ³pico atual: ${agentContext?.currentTopic || 'geral'}
- Tom sugerido: ${agentContext?.suggestedTone || 'balanceado'}
- Primeira interaÃ§Ã£o: ${agentContext?.isFirstTime ? 'Sim' : 'NÃ£o'}
- Estilo do usuÃ¡rio: ${agentContext?.userStyle || 'neutro'}
- Sentimento: ${agentContext?.sentiment || 'neutro'}
- UrgÃªncia: ${agentContext?.urgency || 'baixa'}
- IntenÃ§Ã£o: ${agentContext?.intent || 'declaraÃ§Ã£o'}
${agentContext?.contextualHints?.length > 0 ? `- Dicas: ${agentContext.contextualHints.join(', ')}` : ''}
${agentContext?.previousTopic ? `- TÃ³pico anterior: ${agentContext.previousTopic}` : ''}

ğŸ¯ INSTRUÃ‡Ã•ES CRÃTICAS - SIGA RIGOROSAMENTE:

REGRA #1: Quando o prospect mencionar QUALQUER DOR ou DESAFIO (ex: "captaÃ§Ã£o", "follow-up", "perda de tempo", "falta de resposta", "atolados"), vocÃª DEVE:
1. Reconhecer a dor brevemente (1 frase)
2. Apresentar SOLUÃ‡ÃƒO especÃ­fica da Digital Boost (2 frases)
3. Propor reuniÃ£o de 15min

REGRA #2: NUNCA pergunte "quais desafios" depois que o prospect JÃ mencionou um desafio.

REGRA #3: NUNCA faÃ§a mais de 1 pergunta sobre a mesma dor.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EXEMPLOS OBRIGATÃ“RIOS - COPIE ESTE PADRÃƒO:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âŒ ERRADO (NÃƒO FAÃ‡A ISSO):
Prospect: "CaptaÃ§Ã£o de clientes e follow-up"
VocÃª: "Entendi! Quais desafios vocÃª tem enfrentado?"
â†’ ERRO: Perguntou sobre desafios quando o prospect JÃ disse o desafio!

âœ… CORRETO (FAÃ‡A ASSIM):
Prospect: "CaptaÃ§Ã£o de clientes e follow-up"
VocÃª: "Perfeito, entendo! Nosso agente de IA funciona 24/7 no WhatsApp: responde leads instantaneamente, qualifica automaticamente e nunca esquece follow-up. Quer ver na prÃ¡tica em 15min?"

---

âŒ ERRADO:
Prospect: "Perca de tempo com atendimento"
VocÃª: "Isso pode ser frustrante. Quantas horas vocÃª gasta?"
â†’ ERRO: Perguntou detalhe numÃ©rico desnecessÃ¡rio!

âœ… CORRETO:
Prospect: "Perca de tempo com atendimento"
VocÃª: "Imagina recuperar essas horas! Nosso agente automatiza atendimento 24/7, qualifica leads e agenda reuniÃµes sozinho. Seu time foca sÃ³ no fechamento. Bora ver como? 15min de call?"

---

âŒ ERRADO:
Prospect: "Perdemos leads por demora"
VocÃª: "Entendo. Quais outros problemas vocÃª tem?"
â†’ ERRO: Perguntou outro problema quando jÃ¡ tem informaÃ§Ã£o suficiente!

âœ… CORRETO:
Prospect: "Perdemos leads por demora"
VocÃª: "Ã‰ frustrante mesmo! Com IA respondemos em segundos, zero lead perdido. Funciona no WhatsApp que seus clientes jÃ¡ usam. Vamos falar 15min sobre seu caso?"

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ¯ FLUXO MÃXIMO: 4 mensagens atÃ© propor reuniÃ£o
ğŸ“ Respostas: 2-3 frases curtas (WhatsApp style)

${enhancedContext ? buildEnhancedContextPrompt(enhancedContext) : ''}

Responda sempre em portuguÃªs brasileiro, de forma natural e conversacional, como um consultor experiente que conhece profundamente o mercado potiguar.`
    }
  ];
}

/**
 * Gera resposta da LLM com inteligÃªncia de vendas integrada.
 * @param {string} userText texto do usuÃ¡rio
 * @param {Array} history histÃ³rico opcional em [{role, content}]
 * @param {Object} context contexto adicional (persona, qualification, etc)
 * @returns {Promise<{answer: string, salesData?: Object}>}
 */
export async function agent(userText, history = [], context = {}) {
  const startTime = Date.now();

  // Usar singleton OpenAI Client
  if (!openaiClient.isReady()) {
    return {
      answer:
        "A chave OPENAI_API_KEY nÃ£o estÃ¡ configurada. Abra seu .env e defina OPENAI_API_KEY=SEU_TOKEN. Depois reinicie o servidor."
    };
  }

  // ğŸ”§ INICIALIZANDO ARRAY DE MENSAGENS (corrigido problema de hoisting)
  let messages = [];

  // ğŸ¤ TRATAMENTO ESPECIAL PARA MENSAGENS DE ÃUDIO
  const messageType = context.messageType || 'text';

  if (messageType === 'audio_processing') {
    console.log('ğŸ¤ [AGENT] Ignorando mensagem de Ã¡udio em processamento');
    return {
      answer: null, // NÃ£o responde para mensagens de processamento
      shouldSendResponse: false
    };
  }

  if (messageType === 'audio_transcribed' && context.metadata?.originalAudio) {
    console.log('ğŸ¤ [AGENT] Processando mensagem de Ã¡udio transcrita');
    // Continuar processamento normal, mas marcar origem
    context.fromAudio = true;
  }

  // ğŸ¯ SISTEMA DE VOZ UNIFICADO - ARQUITETURA SIMPLIFICADA
  //
  // FLUXO: Frontend â†’ Server â†’ Agent.js â†’ isDashboardCommand() â†’ LLM ou Cache
  // â€¢ isDashboardCommand() Ã© FONTE ÃšNICA para detecÃ§Ã£o
  // â€¢ dashboard_voice_navigator.js contÃ©m TODAS as palavras-chave
  // â€¢ Cache inteligente processa comandos reconhecidos automaticamente
  let voiceNavigationPrompt = '';

  // ğŸ›¡ï¸ PROTEÃ‡ÃƒO CRÃTICA: NUNCA processar mensagens do WhatsApp como navegaÃ§Ã£o por voz
  const isWhatsAppMessage = context.whatsapp || context.fromWhatsApp || context.platform === 'whatsapp';
  const isVoiceDashboard = context.platform === 'dashboard_web' && (context.fromVoiceInput || context.inputMethod === 'voice');
  const isDirectVoiceCall = context.directVoiceCall === true; // Nova flag para chamadas diretas
  const shouldProcessVoiceNav = (isVoiceDashboard || isDirectVoiceCall) && !isWhatsAppMessage;

  console.log(`ğŸ” [VOICE-DEBUG] Contexto detectado:`, {
    isWhatsAppMessage,
    isVoiceDashboard,
    isDirectVoiceCall,
    shouldProcessVoiceNav,
    platform: context.platform
  });

  // Sistema de voz removido - processamento direto


  // ğŸ§  ANÃLISE DE CONTEXTO INTELIGENTE - OTIMIZADA
  // âš¡ Using pre-loaded module instead of dynamic import
  const contactId = context.fromContact || 'unknown';

  let fullContext, agentContext;
  const isVoiceOrAPIContext = context.platform === 'dashboard_web' || context.fromVoiceInput || context.inputMethod === 'voice' || !context.whatsapp;

  if (isVoiceOrAPIContext) {
    // âš¡ OTIMIZAÃ‡ÃƒO VOZ/API: AnÃ¡lise de contexto simplificada para velocidade mÃ¡xima
    console.log('âš¡ [PERFORMANCE] AnÃ¡lise de contexto simplificada para interaÃ§Ã£o via API/voz');

    // Contexto bÃ¡sico e rÃ¡pido
    fullContext = {
      topic: 'general_inquiry',
      sentiment: 'neutral',
      intent: 'question',
      urgency: 'medium',
      businessContext: false,
      conversationStage: 'active'
    };

    agentContext = {
      currentTopic: 'Consulta geral',
      suggestedTone: 'profissional e direto',
      contextualPrompt: 'Responda de forma concisa e precisa.',
      priority: 'normal'
    };
  } else {
    // AnÃ¡lise completa para WhatsApp e outros contextos
    console.time('ğŸ§  Context Analysis');
    fullContext = await contextManager.analyzeContext(userText, contactId, context);
    agentContext = contextManager.generateAgentContext(fullContext);
    console.timeEnd('ğŸ§  Context Analysis');
  }

  console.log(`ğŸ§  [CONTEXT] Contexto analisado: ${agentContext.currentTopic} (${agentContext.suggestedTone})`);

  // ğŸ¯ DETECÃ‡ÃƒO DE INTENÃ‡ÃƒO: CONHECER A DIGITAL BOOST
  const wantsDigitalBoostInfo = detectDigitalBoostIntent(userText);
  const isWhatsAppForBoost = context.whatsapp || context.fromWhatsApp || context.platform === 'whatsapp';

  // Verificar se jÃ¡ perguntamos a preferÃªncia (ANTES de checar detecÃ§Ã£o)
  const awaitingPreference = await getMemory(`digitalboost_awaiting_${contactId}`);

  console.log(`ğŸ” [DIGITAL-BOOST-DEBUG] DetecÃ§Ã£o: wantsInfo=${wantsDigitalBoostInfo}, isWhatsApp=${isWhatsAppForBoost}, awaiting=${awaitingPreference}, texto="${userText}"`);

  // Processar se detectou intenÃ§Ã£o OU se estÃ¡ aguardando resposta
  if ((wantsDigitalBoostInfo || awaitingPreference === 'true') && isWhatsAppForBoost) {
    console.log('ğŸ’¡ [DIGITAL-BOOST] IntenÃ§Ã£o detectada ou aguardando escolha do usuÃ¡rio');

    if (awaitingPreference === 'true') {
      // UsuÃ¡rio jÃ¡ foi questionado, detectar escolha
      const preference = detectPreferenceChoice(userText);

      if (preference === 'audio') {
        console.log('ğŸ¤ [DIGITAL-BOOST] UsuÃ¡rio escolheu ÃUDIO');
        await setMemory(`digitalboost_awaiting_${contactId}`, 'false');

        // Retornar sinal especial para enviar Ã¡udio
        return {
          answer: "Perfeito! Vou te enviar um Ã¡udio explicando sobre a Digital Boost.",
          sendDigitalBoostAudio: true,
          contactId,
          success: true
        };

      } else if (preference === 'texto') {
        console.log('ğŸ“ [DIGITAL-BOOST] UsuÃ¡rio escolheu TEXTO');
        await setMemory(`digitalboost_awaiting_${contactId}`, 'false');

        // Retornar explicaÃ§Ã£o em texto
        return {
          answer: DIGITAL_BOOST_EXPLANATION_TEXT,
          success: true
        };

      } else {
        // NÃ£o detectou preferÃªncia clara, perguntar novamente
        return {
          answer: "Desculpa, nÃ£o entendi. VocÃª prefere que eu explique por *Ã¡udio* ou por *mensagem de texto*?",
          success: true
        };
      }
    } else {
      // Primeira vez que pergunta, oferecer escolha
      console.log('â“ [DIGITAL-BOOST] Perguntando preferÃªncia: Ã¡udio ou texto');
      await setMemory(`digitalboost_awaiting_${contactId}`, 'true');

      return {
        answer: "Legal que quer conhecer a Digital Boost! ğŸ˜Š\n\nVocÃª prefere que eu explique por *Ã¡udio* (mais rÃ¡pido) ou por *mensagem de texto* (para ler com calma)?",
        success: true
      };
    }
  }

  // âš¡ CACHE INTELIGENTE - VERIFICAR RESPOSTA RÃPIDA (usando singleton persistente)
  // BYPASS CACHE para comandos de navegaÃ§Ã£o por voz E Digital Boost
  const isVoiceNavigationCommand = voiceNavigationPrompt && voiceNavigationPrompt.length > 0;
  // Usar awaitingPreference jÃ¡ carregado acima (linha 230)
  const shouldBypassCache = isVoiceNavigationCommand || wantsDigitalBoostInfo || awaitingPreference === 'true';

  let cachedResponse = null;

  if (!shouldBypassCache) {
    const cacheContext = { ...context, agentContext, topic: agentContext.currentTopic };
    cachedResponse = await responseCache.getResponse(userText, cacheContext);
  } else {
    if (isVoiceNavigationCommand) {
      console.log('ğŸ™ï¸ [NAVIGATION-CACHE] Bypassing cache for navigation command');
    }
    if (wantsDigitalBoostInfo || awaitingPreference === 'true') {
      console.log('ğŸ’¡ [DIGITAL-BOOST-CACHE] Bypassing cache for Digital Boost interaction');
    }
  }

  if (cachedResponse) {
    console.log(`âš¡ [CACHE] Resposta ${cachedResponse.source} encontrada - economizando tempo de processamento`);

    // ğŸ¯ CORREÃ‡ÃƒO CRÃTICA: Aplicar sistema flexÃ­vel MESMO em respostas em cache
    // âš¡ Using pre-loaded scopeLimiter module
    const cacheContext = {
      ...context,
      agentContext,
      topic: agentContext.currentTopic,
      // ğŸ¯ GARANTIR que contexto de voz seja preservado para cache
      fromVoice: context.fromVoice,
      fromVoiceInput: context.fromVoiceInput,
      inputMethod: context.inputMethod,
      voice: context.voice,
      platform: context.platform
    };

    // ğŸ›¡ï¸ DESABILITAR SCOPE LIMITER PARA WHATSAPP - deixar conversa livre
    const isWhatsAppCacheContext = context.whatsapp || context.fromWhatsApp || context.platform === 'whatsapp';
    let filteredCacheResponse = cachedResponse.response;
    let scopeAnalysis = null;

    if (!isWhatsAppCacheContext) {
      scopeAnalysis = await scopeLimiter.analyzeScope(userText, cacheContext);
      console.log(`ğŸ¯ [SCOPE-CACHE] AnÃ¡lise em resposta cacheada: ${scopeAnalysis.isInScope ? 'PERMITIDO' : 'FILTRADO'} (${scopeAnalysis.confidence.toFixed(2)})`);

      // Filtrar resposta do cache com sistema flexÃ­vel (apenas dashboard)
      filteredCacheResponse = await scopeLimiter.filterAgentResponse(cachedResponse.response, userText, scopeAnalysis);
    } else {
      console.log('ğŸ“± [SCOPE-CACHE] Scope limiter desabilitado para WhatsApp - conversa livre');
    }

    // ğŸ”¥ CORREÃ‡ÃƒO CRÃTICA: Preservar estrutura JSON original para comandos de navegaÃ§Ã£o
    if (typeof cachedResponse.response === 'object' && cachedResponse.response.action) {
      // Resposta JSON estruturada (ex: comandos de navegaÃ§Ã£o)
      return {
        answer: cachedResponse.response.response || filteredCacheResponse,
        response: cachedResponse.response.response || filteredCacheResponse,
        action: cachedResponse.response.action,
        instructions: cachedResponse.response.instructions,
        cached: true,
        cacheSource: cachedResponse.source,
        similarity: cachedResponse.similarity,
        scopeAnalysis: isWhatsAppCacheContext ? null : scopeAnalysis,
        fullContext,
        agentContext,
        success: true
      };
    } else {
      // Resposta de texto simples
      return {
        answer: filteredCacheResponse,
        response: filteredCacheResponse, // ğŸ”¥ ADICIONADO: propriedade response que o orchestrator espera
        cached: true,
        cacheSource: cachedResponse.source,
        similarity: cachedResponse.similarity,
        scopeAnalysis: isWhatsAppCacheContext ? null : scopeAnalysis,
        fullContext,
        agentContext,
        action: 'cached_response',
        success: true
      };
    }
  }

  // ğŸ¯ ANÃLISE DE ESCOPO - MOVIDA PARA DEPOIS DA GERAÃ‡ÃƒO DE RESPOSTA (FLUXO CORRIGIDO)
  // Agora apenas salvamos para usar depois, sem bloquear entrada
  // âš¡ Using pre-loaded scopeLimiter module
  let scopeAnalysis = null; // SerÃ¡ analisado depois

  console.log(`ğŸ¯ [SCOPE] AnÃ¡lise serÃ¡ feita apÃ³s geraÃ§Ã£o da resposta (novo fluxo)`);

  // CORREÃ‡ÃƒO: NÃ£o bloquear entrada, permitir que response mode calculator funcione

  // âš ï¸ DETECÃ‡ÃƒO DE COMANDO PARAR - PRIORIDADE MÃXIMA
  const stopWords = ['parar', 'pare', 'stop', 'sair', 'remover', 'cancelar', 'bloquear'];
  const userTextLower = userText?.toLowerCase() || '';

  if (stopWords.some(word => userTextLower.includes(word))) {
    console.log('ğŸ›‘ Comando PARAR detectado:', userText);
    return {
      answer: "Entendido! Vou parar por aqui. Obrigado pela conversa! ğŸ‘‹",
      action: 'stop_conversation'
    };
  }

  // ğŸ¯ SALES FLOW CONTROLLER - FORÃ‡A FLUXO ESTRUTURADO
  // âš¡ CORREÃ‡ÃƒO CRÃTICA: Aplicar Sales Flow Controller APENAS para contexto WhatsApp
  // Evita que comandos de voz/dashboard sejam processados como mensagens de vendas
  const isVoiceOrDashboardContext = context.platform === 'dashboard_web' || context.fromVoiceInput || context.inputMethod === 'voice';

  if (!isVoiceOrDashboardContext) {
    console.log('ğŸ¯ [SALES-FLOW] Processando atravÃ©s do Sales Flow Controller (contexto WhatsApp)');

    // âš¡ Using pre-loaded createSalesFlowController module
    const contactNumber = context.from || context.phoneNumber || 'test_contact';
    const flowController = createSalesFlowController(contactNumber);

    // ğŸš€ PROCESSAR ATRAVÃ‰S DO FLUXO ESTRUTURADO (APENAS PARA WHATSAPP)
    const flowResult = await flowController.processMessage(userText, history);

    if (flowResult.forceStructuredResponse) {
    console.log(`ğŸ¯ [AGENT] Usando resposta estruturada do fluxo: ${flowResult.currentStage}`);

    // Retornar resposta do fluxo estruturado
    return {
      answer: flowResult.response,
      response: flowResult.response, // â† CORREÃ‡ÃƒO: MessageOrchestrator espera 'response'
      success: true, // â† CORREÃ‡ÃƒO: Garantir que seja marcado como sucesso
      salesData: {
        flowController: true,
        currentStage: flowResult.currentStage,
        nextAction: flowResult.nextAction,
        analysis: flowResult.analysis
      },
      structuredFlow: true,
      processingTime: Date.now() - startTime,
      timestamp: new Date().toISOString()
    };
    }
  } else {
    console.log('ğŸ™ï¸ [SALES-FLOW] Pulando Sales Flow Controller para contexto voz/dashboard - processamento direto');
  }

  // ğŸš€ NOVA INTEGRAÃ‡ÃƒO ENHANCED - Aproveita anÃ¡lise do unified_message_processor
  let enhancedContext = null;
  if (context.useEnhancedContext && context.enhancedState) {
    enhancedContext = context.enhancedState;
    console.log(`ğŸ§  [AGENT ENHANCED] Usando contexto enhanced:`, {
      estado: enhancedContext.state?.current,
      score: enhancedContext.qualification?.score,
      sentimento: enhancedContext.sentiment?.emotion
    });
  }

  // Processo simplificado sem pesquisa externa
  let researchResult = null;

  // ğŸš€ SEPARAÃ‡ÃƒO CRÃTICA: Sistema de voz vs sistema de vendas
  const isVoiceContext = shouldProcessVoiceNav; // Usar a variÃ¡vel jÃ¡ definida anteriormente

  // Integra inteligÃªncia de vendas se disponÃ­vel - APENAS para contextos nÃ£o-voz
  let enhancedSystemPrompt = [];
  let salesAnalysis = null;

  if (!isVoiceContext) {
    // Sistema de vendas/WhatsApp: usar prompts completos
    enhancedSystemPrompt = buildSystemPrompt(enhancedContext, agentContext);
    console.log('ğŸ¯ [SEPARATION] Usando sistema de VENDAS - prompts completos ativados');
  } else {
    // Sistema de voz: prompts minimalistas apenas
    enhancedSystemPrompt = [];
    console.log('ğŸ™ï¸ [SEPARATION] Usando sistema de VOZ - prompts de vendas DESABILITADOS');
  }

  try {
    // âš¡ SEPARAÃ‡ÃƒO CRÃTICA: AnÃ¡lise de vendas APENAS para contextos nÃ£o-voz
    if (!isVoiceContext) {
      console.log('ğŸ¯ [SEPARATION] Iniciando anÃ¡lises de VENDAS para contexto WhatsApp');

      // âš¡ Using pre-loaded sales intelligence modules
      // analyzeConversationFlow, identifyPersona, detectObjection already imported
      // âš¡ analyzeAndSelectArchetype, applyArchetypeToScript, selectArchetypeByPersona, ARCHETYPES already imported

      // OtimizaÃ§Ã£o para diferentes contextos: anÃ¡lise simplificada para velocidade
      const isWhatsAppContext = context.whatsapp || context.fromWhatsApp;
      const isVoiceOrAPIContext = context.platform === 'dashboard_web' || context.fromVoiceInput || context.inputMethod === 'voice' || !context.whatsapp;

    // âš¡ PERFORMANCE OPTIMIZATION: Parallelizar anÃ¡lises independentes
    console.time('âš¡ Parallel Analysis');

    const analysisPromises = [];

    // 1. Sales Analysis - executar apenas se hÃ¡ histÃ³rico
    if (history.length > 0) {
      if (isWhatsAppContext && history.length < 3) {
        // Para WhatsApp com pouco histÃ³rico, faz anÃ¡lise bÃ¡sica rÃ¡pida (sÃ­ncrona)
        salesAnalysis = {
          current_stage: 'initial_contact',
          next_stage: 'interest_discovery',
          interest_level: 5,
          pain_points: ['necessita de soluÃ§Ãµes'],
          sales_strategy: 'Descobrir necessidades e qualificar interesse',
          response_tone: 'consultivo e direto',
          ready_for_meeting: false
        };
      } else {
        // Executar anÃ¡lise de vendas em paralelo (assÃ­ncrona)
        analysisPromises.push(
          analyzeConversationFlow(userText, history).then(result => ({ type: 'sales', data: result }))
        );
      }
    }

    // 2. Persona Analysis - executar se hÃ¡ contexto empresarial (sÃ­ncrona, mas pode ser executada em paralelo com outras operaÃ§Ãµes sÃ­ncronas)
    let personaData = null;
    if (context.businessInfo || userText.length > 50) {
      personaData = identifyPersona(
        context.businessInfo || userText,
        [],
        [],
        context.leadName || context.contactName || ''
      );
      context.persona = personaData;
    }

    // 3. Keyword Detection - executar de forma otimizada (operaÃ§Ãµes sÃ­ncronas leves)
    // âš¡ SEPARAÃ‡ÃƒO: Funcionalidades SDR apenas para WhatsApp, nÃ£o para voz/dashboard
    const objectionKeywords = ['caro', 'orÃ§amento', 'momento', 'ocupado', 'sÃ³cio', 'decidir', 'complexo'];
    const meetingKeywords = ['agendar', 'reuniÃ£o', 'meeting', 'marcar', 'conversar', 'encontro', 'horÃ¡rio', 'amanhÃ£', 'hoje', 'segunda', 'terÃ§a', 'quarta', 'quinta', 'sexta', 'manhÃ£', 'tarde', 'Ã s', 'horas'];

    const lowerUserText = userText.toLowerCase();

    // âš¡ SEPARAÃ‡ÃƒO CRÃTICA: Funcionalidades SDR SOMENTE para contexto WhatsApp
    const hasObjection = !isVoiceOrAPIContext && objectionKeywords.some(keyword => lowerUserText.includes(keyword));
    const hasMeetingRequest = !isVoiceOrAPIContext && meetingKeywords.some(keyword => lowerUserText.includes(keyword));

    if (isVoiceOrAPIContext && (hasObjection || hasMeetingRequest)) {
      console.log('ğŸš« [AGENT-SEPARATION] Bloqueando funcionalidades SDR para agente de voz/dashboard');
    }

    // 4. Objection Analysis - executar apenas se objeÃ§Ã£o detectada (pode ser paralela)
    if (hasObjection) {
      analysisPromises.push(
        Promise.resolve(detectObjection(userText)).then(result => ({ type: 'objection', data: result }))
      );
    }

    // Aguardar todas as anÃ¡lises paralelas
    const analysisResults = await Promise.all(analysisPromises);

    // Processar resultados das anÃ¡lises paralelas
    for (const result of analysisResults) {
      switch (result.type) {
        case 'sales':
          salesAnalysis = result.data;
          console.log('ğŸ¯ AnÃ¡lise de vendas (paralela):', salesAnalysis);
          break;
        case 'objection':
          context.objectionHandler = result.data;
          console.log('ğŸš« ObjeÃ§Ã£o detectada (paralela):', result.data.objection);
          break;
      }
    }

    // Flags simples (sÃ­ncronas)
    if (hasMeetingRequest) {
      context.meetingRequest = true;
      console.log('ğŸ“… SolicitaÃ§Ã£o de agendamento detectada');
    }

    if (personaData) {
      console.log('ğŸ‘¤ Persona identificada:', personaData.persona);
    }

    console.timeEnd('âš¡ Parallel Analysis');

    // NOVO: Seleciona arquÃ©tipo baseado no contexto completo
    const salesContext = {
      persona: context.persona?.persona,
      salesStage: salesAnalysis?.current_stage,
      interestLevel: salesAnalysis?.interest_level,
      objection: context.objectionHandler?.objection
    };
    
    let archetypeAnalysis;

    if (isVoiceOrAPIContext) {
      // âš¡ OTIMIZAÃ‡ÃƒO VOZ/API: Pula anÃ¡lise de arquÃ©tipos para velocidade mÃ¡xima
      console.log('âš¡ [ARCHETYPES] DESABILITADO para navegaÃ§Ã£o por voz/dashboard web');
      archetypeAnalysis = null;
    } else if (isWhatsAppContext) {
      // SeleÃ§Ã£o rÃ¡pida baseada em heurÃ­sticas (< 10ms)
      const fastArchetype = selectArchetypeByPersona(context.persona?.persona || 'business_owner', salesContext);
      archetypeAnalysis = {
        archetype: fastArchetype,
        confidence: 0.75,
        reasoning: `SeleÃ§Ã£o rÃ¡pida para WhatsApp baseada em: ${salesContext.persona || 'contexto da mensagem'}`,
        archetypeData: ARCHETYPES[fastArchetype]
      };
      console.log('ğŸ­ [ARCHETYPES] ATIVADO para WhatsApp:', archetypeAnalysis.archetype, '(', archetypeAnalysis.confidence, ')');
    } else {
      // AnÃ¡lise completa com AI para outros canais
      archetypeAnalysis = await analyzeAndSelectArchetype(userText, context.businessInfo || '', salesContext);
      console.log('ğŸ­ ArquÃ©tipo selecionado:', archetypeAnalysis.archetype, '(', archetypeAnalysis.confidence, ')');
    }

    context.archetypeAnalysis = archetypeAnalysis;

    // Enriquece system prompt com contexto de vendas E arquÃ©tipo
    // âš¡ OTIMIZAÃ‡ÃƒO: Para navegaÃ§Ã£o por voz, usa prompt bÃ¡sico sem arquÃ©tipos
    if (isVoiceOrAPIContext) {
      // Sistema de voz/dashboard: sem arquÃ©tipos, apenas anÃ¡lise de vendas se houver
      console.log('ğŸ­ [ARCHETYPES] Prompt SEM arquÃ©tipos para dashboard web/voz');
      if (salesAnalysis || context.persona || context.objectionHandler) {
        // Remove arquÃ©tipo do contexto para navegaÃ§Ã£o por voz
        const contextWithoutArchetype = { ...context, archetypeAnalysis: null };
        enhancedSystemPrompt = buildEnhancedSystemPrompt(salesAnalysis, contextWithoutArchetype);
      }
    } else {
      // WhatsApp e outros canais: com arquÃ©tipos completos
      console.log('ğŸ­ [ARCHETYPES] Prompt COM arquÃ©tipos para WhatsApp/outros canais');
      if (salesAnalysis || context.persona || context.objectionHandler || archetypeAnalysis) {
        enhancedSystemPrompt = buildEnhancedSystemPrompt(salesAnalysis, context);
      }
    }

    } else {
      // ğŸ™ï¸ CONTEXTO DE VOZ: Sem anÃ¡lises de vendas
      console.log('ğŸ™ï¸ [SEPARATION] Contexto de VOZ detectado - pulando TODAS as anÃ¡lises de vendas');
      console.log('ğŸ™ï¸ [SEPARATION] Sistema de voz puro ativado - sem SDR, sem persona, sem arquÃ©tipos');
    }

  } catch (error) {
    if (!isVoiceContext) {
      console.log('âš ï¸ Erro no sistema de vendas - usando prompt bÃ¡sico:', error.message);
    } else {
      console.log('ğŸ™ï¸ [SEPARATION] Sistema de voz nÃ£o precisa de anÃ¡lises de vendas');
    }
  }

  // ğŸš€ CONSTRUÃ‡ÃƒO COMPLETAMENTE SEPARADA: Sistema de voz vs sistema de vendas
  if (isVoiceContext) {
    console.log('ğŸ™ï¸ [SEPARATION] Construindo mensagens para SISTEMA DE VOZ PURO');

    // Para voz: apenas o necessÃ¡rio para navegaÃ§Ã£o/conversaÃ§Ã£o
    messages = [
      ...(Array.isArray(history) ? history : []),
      { role: "user", content: userText || "" }
    ];

    // Adicionar prompt especÃ­fico de voz se necessÃ¡rio
    if (voiceNavigationPrompt) {
      messages.splice(-1, 0, { role: "system", content: voiceNavigationPrompt });
    } else if (messages.length === 1) {
      // Se nÃ£o hÃ¡ prompt de navegaÃ§Ã£o, adicionar prompt mÃ­nimo de voz
      messages.splice(-1, 0, {
        role: "system",
        content: `ğŸ™ï¸ MODO AGENTE DE VOZ - SISTEMA PURO

VocÃª Ã© ORBION, assistente de voz para o dashboard web da Digital Boost.

ğŸ“‹ SOBRE A DIGITAL BOOST:
A Digital Boost Ã© uma empresa de Growth focada em PMEs de Natal/RN, reconhecida pelo Sebrae como uma das 15 melhores startups de tecnologia do Brasil. Oferecemos:

ğŸ¤– **Agentes de IA**: Atendimento e prÃ©-vendas 24/7 com 95% de resoluÃ§Ã£o
ğŸ”§ **CRM Kommo**: AutomaÃ§Ãµes, funis de vendas e playbooks comerciais
ğŸ“ˆ **Consultoria de Growth**: EstratÃ©gias digitais de aquisiÃ§Ã£o, retenÃ§Ã£o e expansÃ£o
ğŸ¯ **EspecializaÃ§Ã£o**: PMEs em Natal e regiÃ£o, com foco em ROI mensurÃ¡vel

DIRETRIZES CRÃTICAS:
- VocÃª estÃ¡ no MODO VOZ PURO (sem funcionalidades de vendas ativas)
- Pode INFORMAR sobre a empresa quando perguntado, mas NUNCA ofereÃ§a vendas
- Foque em: navegaÃ§Ã£o, informaÃ§Ãµes sobre a empresa, e conversas gerais
- NUNCA ofereÃ§a agendamentos, reuniÃµes ou anÃ¡lises comerciais
- Seja natural, direto e Ãºtil

Responda de forma concisa em portuguÃªs brasileiro.`
      });
    }
  } else {
    console.log('ğŸ¯ [SEPARATION] Construindo mensagens para SISTEMA DE VENDAS COMPLETO');

    // Para vendas: sistema completo com todas as inteligÃªncias
    messages = [
      ...enhancedSystemPrompt,
      ...(Array.isArray(history) ? history : []),
      { role: "user", content: userText || "" }
    ];
  }

  // ğŸš€ SEPARAÃ‡ÃƒO DE FERRAMENTAS: Voz vs Vendas
  let availableTools = [];
  let maxTokens = 400; // PadrÃ£o para voz

  if (isVoiceContext) {
    // Sistema de voz: apenas temas, sem sheets (que sÃ£o para vendas)
    availableTools = [...themeTools];
    maxTokens = 300; // Respostas concisas para voz
    console.log('ğŸ™ï¸ [SEPARATION] Ferramentas de VOZ: apenas temas disponÃ­veis');
  } else {
    // Sistema de vendas: ferramentas essenciais + agendamento manual
    const schedulingTools = [
      {
        type: 'function',
        function: {
          name: 'schedule_whatsapp_meeting',
          description: 'Agenda reuniÃ£o no Google Calendar com Google Meet e notifica o cliente via WhatsApp automaticamente.',
          parameters: {
            type: 'object',
            properties: {
              number: { type: 'string', description: 'NÃºmero do WhatsApp (ex: 5511999999999)' },
              email: { type: 'string', description: 'Email do cliente para convite do Google Calendar (OBRIGATÃ“RIO)' },
              title: { type: 'string', description: 'TÃ­tulo/assunto da reuniÃ£o' },
              datetime: { type: 'string', description: 'Data e hora em formato ISO 8601' },
              notes: { type: 'string', description: 'ObservaÃ§Ãµes sobre a reuniÃ£o' }
            },
            required: ['number', 'email', 'title', 'datetime']
          }
        }
      }
    ];

    availableTools = [...sheetsTools, ...themeTools, ...schedulingTools];
    maxTokens = context.whatsapp || context.fromWhatsApp ? 200 : 400;
    console.log('ğŸ¯ [SEPARATION] Ferramentas de VENDAS: sheets + temas + agendamento disponÃ­veis');
  }
  const resp = await openaiClient.createChatCompletion(messages, {
    max_tokens: maxTokens,
    temperature: 0.7,
    tools: availableTools,
    tool_choice: availableTools.length > 0 ? "auto" : "none"
  });

  // Verificar se o agente quer usar tools
  const message = resp.choices?.[0]?.message;

  if (message?.tool_calls && message.tool_calls.length > 0) {
    console.log('ğŸ”§ Agente solicitou tools:', message.tool_calls.map(tc => tc.function.name));

    // Executar todos os tool calls
    const toolResults = [];
    for (const toolCall of message.tool_calls) {
      try {
        const functionName = toolCall.function.name;
        const functionArgs = JSON.parse(toolCall.function.arguments);

        console.log(`ğŸ”§ Executando ${functionName} com argumentos:`, functionArgs);

        // Router para decidir qual executor usar
        let result;
        if (functionName === 'change_theme') {
          result = await executeThemeTool(functionName, functionArgs);
        } else if (functionName === 'schedule_whatsapp_meeting') {
          // Ferramenta de agendamento
          result = await scheduleWhatsAppMeeting(functionArgs.number, functionArgs.email, functionArgs.title, functionArgs.datetime, functionArgs.notes || '');
        } else {
          result = await executeSheetsTool(functionName, functionArgs);
        }

        toolResults.push({
          tool_call_id: toolCall.id,
          role: "tool",
          content: JSON.stringify(result)
        });

        console.log(`âœ… Tool ${functionName} executado com sucesso`);

      } catch (error) {
        console.error(`âŒ Erro ao executar tool ${toolCall.function.name}:`, error);
        toolResults.push({
          tool_call_id: toolCall.id,
          role: "tool",
          content: JSON.stringify({
            success: false,
            error: error.message
          })
        });
      }
    }

    // Segunda chamada: com os resultados dos tools
    const messagesWithTools = [
      ...messages,
      message,
      ...toolResults
    ];

    const finalResp = await openaiClient.createChatCompletion(messagesWithTools, {
      max_tokens: maxTokens,
      temperature: 0.7
    });

    const answer = finalResp.choices?.[0]?.message?.content?.trim() ||
      "Executei as aÃ§Ãµes solicitadas, mas nÃ£o consegui gerar uma resposta.";

    return {
      answer,
      response: answer, // â† CORREÃ‡ÃƒO: MessageOrchestrator espera 'response'
      // Metadados enriquecidos
      model: CHAT_MODEL,
      archetype: context.archetypeAnalysis?.archetype || 'SABIO',
      stage: salesAnalysis?.current_stage || 'initial_contact',
      persona: context.persona?.persona || 'NEUTRO',
      tokens_used: finalResp.usage?.total_tokens || 0,
      processing_time: Date.now() - startTime,
      tools_used: message.tool_calls?.map(tc => tc.function.name) || []
    };
  }

  // Se nÃ£o houve tool calls, retornar resposta normal
  let answer =
    message?.content?.trim() ||
    "NÃ£o consegui gerar uma resposta agora.";

  // ğŸ¯ ANALISAR ESCOPO APÃ“S GERAR RESPOSTA (FLUXO CORRIGIDO)
  // ğŸ›¡ï¸ DESABILITAR SCOPE LIMITER PARA WHATSAPP - deixar conversa livre
  const isWhatsAppContext = context.whatsapp || context.fromWhatsApp || context.platform === 'whatsapp';

  if (!isWhatsAppContext) {
    scopeAnalysis = await scopeLimiter.analyzeScope(userText, context);
    console.log(`ğŸ¯ [SCOPE] AnÃ¡lise pÃ³s-resposta: ${scopeAnalysis.isInScope ? 'PERMITIDO' : 'FILTRADO'} (${scopeAnalysis.confidence.toFixed(2)})`);

    // ğŸ¯ FILTRAR RESPOSTA COM LIMITADOR DE ESCOPO (apenas dashboard)
    answer = await scopeLimiter.filterAgentResponse(answer, userText, scopeAnalysis);
  } else {
    console.log('ğŸ“± [SCOPE] Scope limiter desabilitado para WhatsApp - conversa livre');
  }

  // ğŸ¯ DETECTAR COMANDOS DE NAVEGAÃ‡ÃƒO POR VOZ NO GPT RESPONSE
  let voiceNavigationResult = null;

  // ğŸ›¡ï¸ PROTEÃ‡ÃƒO CRÃTICA: NUNCA processar mensagens do WhatsApp como navegaÃ§Ã£o por voz
  const isWhatsAppMessage2 = context.whatsapp || context.fromWhatsApp || context.platform === 'whatsapp';
  const isVoiceDashboard2 = context.platform === 'dashboard_web' && (context.fromVoiceInput || context.inputMethod === 'voice');
  const shouldProcessVoiceNav2 = isVoiceDashboard2 && !isWhatsAppMessage2;

  if (shouldProcessVoiceNav2) {
    try {
      // Tentar parsear resposta como JSON se contÃ©m action: voice_navigation
      if (answer.includes('"action":') && answer.includes('voice_navigation')) {
        // Buscar JSON de forma mais flexÃ­vel - mÃºltiplas tentativas
        // Buscar JSON vÃ¡lido mais robustamente
        const jsonCandidates = [];

        // MÃ©todo 1: Procurar por JSON completo balanceado
        let braceCount = 0;
        let startIndex = -1;
        for (let i = 0; i < answer.length; i++) {
          if (answer[i] === '{') {
            if (braceCount === 0) startIndex = i;
            braceCount++;
          } else if (answer[i] === '}') {
            braceCount--;
            if (braceCount === 0 && startIndex !== -1) {
              jsonCandidates.push(answer.substring(startIndex, i + 1));
            }
          }
        }

        // MÃ©todo 2: Fallback para regex tradicional
        if (jsonCandidates.length === 0) {
          const regexMatch = answer.match(/\{[^{}]*"action"[^{}]*\}/);
          if (regexMatch) jsonCandidates.push(regexMatch[0]);
        }

        // Tentar parsear cada candidato
        for (const jsonCandidate of jsonCandidates) {
          try {
            const parsedResponse = JSON.parse(jsonCandidate);
            if (parsedResponse.action === 'voice_navigation') {
              console.log('ğŸ™ï¸ [VOICE-INTELLIGENCE] GPT detectou comando de navegaÃ§Ã£o:', parsedResponse);

              // ğŸ”§ GARANTIR QUE INSTRUCTIONS TEM CAMPO JAVASCRIPT
              let instructions = parsedResponse.instructions;
              if (instructions && !instructions.javascript && instructions.target) {
                // Se nÃ£o tem javascript mas tem target, gerar via dashboard_voice_navigator
                const navResult = dashboardVoiceNavigator.generateJavaScriptForTarget(instructions.target);
                if (navResult) {
                  instructions.javascript = navResult.javascript;
                  console.log('ğŸ”§ [VOICE-FIX] JavaScript gerado para target:', instructions.target, 'â†’', instructions.javascript);
                }
              }

              voiceNavigationResult = {
                action: 'voice_navigation',
                response: parsedResponse.response || answer,
                instructions: instructions
              };
              // Use a resposta limpa sem JSON
              answer = parsedResponse.response || answer.replace(jsonCandidate, '').trim();
              break;
            }
          } catch (parseError) {
            // Silencioso para nÃ£o poluir logs - Ã© esperado ter alguns candidatos invÃ¡lidos
            continue;
          }
        }
      }
    } catch (error) {
      console.log('ğŸ™ï¸ [VOICE-INTELLIGENCE] Erro ao parsear resposta de navegaÃ§Ã£o:', error);
    }
  }

  // ğŸ’¾ SALVAR RESPOSTA NO CACHE PARA ACELERAR FUTURAS CONSULTAS
  const saveCacheContext = {
    topic: scopeAnalysis?.detectedTopics?.[0]?.name || 'general',
    fromAudio: context.fromAudio || false,
    stage: salesAnalysis?.current_stage || 'initial_contact'
  };
  await responseCache.cacheResponse(userText, answer, saveCacheContext);

  // ğŸ¯ RETORNAR RESPOSTA COM NAVEGAÃ‡ÃƒO POR VOZ SE DETECTADA
  if (voiceNavigationResult) {
    console.log('ğŸ™ï¸ [VOICE-FINAL] Retornando resultado de navegaÃ§Ã£o:', {
      action: voiceNavigationResult.action,
      instructions: voiceNavigationResult.instructions,
      hasJavaScript: !!(voiceNavigationResult.instructions && voiceNavigationResult.instructions.javascript)
    });

    return {
      answer,
      response: voiceNavigationResult.response,
      action: voiceNavigationResult.action,
      instructions: voiceNavigationResult.instructions,
      dashboardCommand: true,
      success: true,
      processingTime: Date.now() - startTime,
      model: CHAT_MODEL
    };
  }

  return {
    answer,
    response: answer, // â† CORREÃ‡ÃƒO: MessageOrchestrator espera 'response'
    success: true, // â† CORREÃ‡ÃƒO: Garantir que seja marcado como sucesso
    salesData: {
      analysis: salesAnalysis,
      persona: context.persona,
      objectionHandler: context.objectionHandler,
      archetype: context.archetypeAnalysis
    },
    // ğŸš€ ENHANCED CONTEXT INTEGRATION
    enhancedContext: enhancedContext ? {
      conversationState: enhancedContext.state?.current,
      subState: enhancedContext.state?.subState,
      qualificationScore: enhancedContext.qualification?.score,
      sentiment: enhancedContext.sentiment,
      engagement: enhancedContext.engagement,
      momentum: enhancedContext.engagement?.momentum,
      nextBestAction: enhancedContext.nextBestAction,
      processingVersion: '4.0.0-bridge'
    } : null,
    processingTime: Date.now() - startTime,
    timestamp: new Date().toISOString(),
    aiEnhanced: !!enhancedContext
  };
}

/**
 * ConstrÃ³i prompt enriquecido com inteligÃªncia de vendas
 */
function buildEnhancedSystemPrompt(salesAnalysis, context) {
  const basePrompt = buildSystemPrompt()[0];
  
  let enhancementText = "";
  
  // Adiciona contexto da anÃ¡lise de vendas
  if (salesAnalysis) {
    enhancementText += `\n\nğŸ¯ CONTEXTO ATUAL DA CONVERSA:
- EstÃ¡gio: ${salesAnalysis.current_stage} â†’ ${salesAnalysis.next_stage}
- NÃ­vel de interesse: ${salesAnalysis.interest_level}/10
- Dores identificadas: ${salesAnalysis.pain_points.join(', ')}
- EstratÃ©gia: ${salesAnalysis.sales_strategy}
- Tom recomendado: ${salesAnalysis.response_tone}
- Pronto para reuniÃ£o: ${salesAnalysis.ready_for_meeting ? 'SIM' : 'NÃƒO'}`;
  }
  
  // Adiciona contexto da persona
  if (context.persona) {
    const persona = context.persona.profile;
    enhancementText += `\n\nğŸ‘¤ PERSONA IDENTIFICADA: ${persona.title}
- Dores tÃ­picas: ${persona.pain_points.slice(0, 3).join(', ')}
- Objetivos: ${persona.goals.slice(0, 2).join(', ')}
- ObjeÃ§Ãµes comuns: ${persona.objections.slice(0, 2).join(', ')}
- Hook recomendado: ${persona.approach.hook}`;
  }
  
  // Adiciona contexto de objeÃ§Ã£o
  if (context.objectionHandler) {
    enhancementText += `\n\nğŸš« OBJEÃ‡ÃƒO DETECTADA: ${context.objectionHandler.objection}
- Resposta sugerida: ${context.objectionHandler.response}
- Follow-up: ${context.objectionHandler.follow_up}`;
  }
  
  
  // NOVO: Adiciona contexto do arquÃ©tipo selecionado
  if (context.archetypeAnalysis) {
    const archetype = context.archetypeAnalysis.archetypeData;
    enhancementText += `\n\nğŸ­ ARQUÃ‰TIPO ATIVADO: ${archetype.name} (${context.archetypeAnalysis.confidence})
- MotivaÃ§Ã£o Core: ${archetype.coreMotivation}
- Estilo de Voz: ${archetype.voiceStyle}
- Valores a Incorporar: ${archetype.coreValues.slice(0, 3).join(', ')}
- Abordagem de Discovery: ${archetype.salesApproach.discovery}
- Tratamento de ObjeÃ§Ãµes: ${archetype.salesApproach.objection}
- EstratÃ©gia de Fechamento: ${archetype.salesApproach.closing}
- RazÃ£o da SeleÃ§Ã£o: ${context.archetypeAnalysis.reasoning}

INSTRUÃ‡ÃƒO CRITICAL: Use EXATAMENTE o tom, linguagem e abordagem do arquÃ©tipo ${archetype.name}. Incorpore os valores core na sua resposta e aplique a estratÃ©gia de vendas especÃ­fica deste arquÃ©tipo.`;
  }
  
  // Adiciona instruÃ§Ãµes especÃ­ficas baseadas no contexto
  if (salesAnalysis?.ready_for_meeting) {
    const archetypeClosing = context.archetypeAnalysis?.archetypeData?.salesApproach?.closing || 'solicite reuniÃ£o diretamente';
    enhancementText += `\n\nâš¡ AÃ‡ÃƒO PRIORITÃRIA: SOLICITAR REUNIÃƒO AGORA
Use a abordagem do arquÃ©tipo ${context.archetypeAnalysis?.archetype || 'SABIO'}: ${archetypeClosing}
Exemplo: "Baseado no que conversamos, vejo uma oportunidade real de ${salesAnalysis.pain_points[0] ? 'resolver ' + salesAnalysis.pain_points[0] : 'te ajudar'}. Que tal uma Consultoria EstratÃ©gica Gratuita de 30min com Taylor Lapenda ainda esta semana?"`;
  }

  // InstruÃ§Ãµes especÃ­ficas para agendamento
  if (context.meetingRequest) {
    enhancementText += `\n\nğŸ“… SOLICITAÃ‡ÃƒO DE AGENDAMENTO DETECTADA!

ğŸ¯ AÃ‡ÃƒO OBRIGATÃ“RIA: USE A FERRAMENTA schedule_whatsapp_meeting
- Cliente demonstrou interesse em agendar
- SEMPRE use a ferramenta para confirmar o agendamento
- Formato: schedule_whatsapp_meeting(nÃºmero, tÃ­tulo, datetime, observaÃ§Ãµes)
- Exemplo de datetime: "2024-09-15T14:00:00.000Z" (formato ISO)
- TÃ­tulo sugerido: "ReuniÃ£o EstratÃ©gica Digital Boost - [Nome do Cliente]"

FLUXO DE AGENDAMENTO:
1. Confirme interesse e colete dados (nome, melhor horÃ¡rio)
2. Sugira 2-3 opÃ§Ãµes de horÃ¡rio
3. Quando cliente confirmar: USE IMEDIATAMENTE a ferramenta schedule_whatsapp_meeting
4. Confirme o agendamento criado

âš ï¸ CRÃTICO: NÃƒO apenas fale sobre agendar - EFETIVAMENTE agende usando a ferramenta!`;
  }

  return [{
    role: "system",
    content: basePrompt.content + enhancementText
  }];
}

/**
 * Wrapper Express compatÃ­vel com o server.js
 * POST /api/chat => { user_message, history? }
 */
export async function chatHandler(req, res) {
  // Esta funÃ§Ã£o Ã© especificamente para endpoints Express.js
  // NÃƒO deve ser chamada diretamente - use agent() para chamadas diretas
  if (!res || typeof res.json !== 'function') {
    throw new Error('chatHandler requires Express response object. Use agent() for direct calls.');
  }

  try {
    const body = req.body || {};
    const text = (body.user_message || body.message || "").toString().trim();
    const history = Array.isArray(body.history) ? body.history : [];

    if (!text) {
      return res.json({ answer: "Mensagem vazia." });
    }

    // Extract lead/contact information for intelligent persona analysis
    const context = {
      leadName: body.leadName || body.contactName || body.profileName || "",
      contactName: body.contactName || body.leadName || body.profileName || "",
      businessInfo: body.businessInfo || "",
      whatsapp: body.fromWhatsApp || body.whatsapp || false,
      fromWhatsApp: body.fromWhatsApp || false
    };

    const out = await agent(text, history, context);
    const answer = typeof out === "string" ? out : out?.answer || "Sem resposta.";
    return res.json({ answer, ...(typeof out === "object" ? out : {}) });
  } catch (err) {
    console.error("Erro no chatHandler:", err);
    return res.status(500).json({ answer: "Falha no agente." });
  }
}

